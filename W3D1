--================== WEEK 3 DAY 1 ====================---
--------------------KYUNG KWAN JANG ---------------------

--FIND CONSTRAINTS


INSERT INTO EMP(EMPNO, ENAME) VALUES (7499, 'LUKE');
SELECT * FROM EMP;

SELECT * FROM USER_CONSTRAINTS;

INSERT INTO STUDENT(STUDNO, NAME, ID, GRADE, JUMIN)
VALUES (9999, 'LUKE', 'AA', 15,'9201221177444');
--> SYS_C0011048 위배
--> 어떤 컬럼에 대한 제약 조건??

1) 제약이름, 종류 확인: : USER_CONSTAINS;
SELECT * FROM USER_CONSTRAINTS;"DEPTNO" IS NOT NULL

SELECT * FROM USER_CONSTRAINTS WHERE CONSTRAINT_NAME = 'SYS_C0011048';

2) 제약조건 이름, 컬럼 확인 : USER_CONS_COLUMS;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = EMP AND TABLE_NAME = DEPT;

SELECT * FROM USER_CONS_COLUMNS WHERE CONSTRAINT_NAME = 'SYS_C0011048';

--3) 위의 두 뷰를 사용하여 테이블명, 제약조건, 컬럼이름, 제약조건 타입, SERCH CONDITION 확인하는 퀴리 작성

SELECT UC.TABLE_NAME, UC.CONSTRAINT_NAME, UCC.COLUMN_NAME, UC.CONSTRAINT_TYPE, UC.SEARCH_CONDITION
  FROM USER_CONSTRAINTS UC, USER_CONS_COLUMNS UCC
 WHERE UC.TABLE_NAME = UCC.TABLE_NAME AND UC.CONSTRAINT_NAME = 'SYS_C0011048' AND UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;

--- FORIEGN KEY - PARENT KEY CHECK
--R_CONSTRAINT_NAME....  BUT YOU CAN'T CHECK WHICH TABLE!
--4) PRINT REFERENCE KEY AND REFERENCE TABLE, PARENT TABLE, PARENTS COLUMN

SELECT U1.TABLE_NAME,
       U1.R_CONSTRAINT_NAME,
       U1.CONSTRAINT_TYPE,
       U2.TABLE_NAME,
       U2.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS U1,
       USER_CONSTRAINTS U2,
       USER_CONS_COLUMNS UCC
 WHERE U1.R_CONSTRAINT_NAME = U2.CONSTRAINT_NAME;
 
----A)
SELECT U1.TABLE_NAME,
       U1.CONSTRAINT_NAME,
       U2.COLUMN_NAME,
       U1.CONSTRAINT_TYPE,
       U1.SEARCH_CONDITION,
       U3.TABLE_NAME AS REFERENCE_TABLE,
       U4.COLUMN_NAME AS REFERENCE_KEY
  FROM USER_CONSTRAINTS U1,
       USER_CONS_COLUMNS U2,
       USER_CONSTRAINTS U3,
       USER_CONS_COLUMNS U4
 WHERE U1.R_CONSTRAINT_NAME = U3.CONSTRAINT_NAME
   AND U1.CONSTRAINT_NAME = U2.CONSTRAINT_NAME(+)
   AND U3.CONSTRAINT_NAME = U4.CONSTRAINT_NAME(+);

U1 - U2
|
UCC
|
U4
 ;
 
 --==DROP CONSTAINT==--
 -- DROP, YOU CAN RESOTRE TABLE. BUT IF YOU DROP COLUMNS, YOU CAN BOT RESCOVER.
 
ALTER TABLE TABLE_NAME DROP COLUMNS COLUMN_NAME;
ALTER TABLE TABLE_NAME DROP CONSTRAINTS CONSTRAINT_NAME;

--============ INDEX ==================--
--DATABASE BUFFER CACHE

SELECT ROWID, EMPNO, ENAME
  FROM EMP;

-- INDEX: 조회를 빠르게 하는 장치, WHERE 부분에서 자주 언급되는 컬럼에 주로 생성
--** HOW TO CHECK SCANNING ORDER :  'CTRL + E' 

SELECT * FROM EMP WHERE EMPNO = 7499; --EMPNO 에서 INDEX 생성

SELECT * FROM EMP WHERE ENAME = 'ALLEN'; -- INDEX NOT UTILIZED!

CREATE INDEX IDX_EMP_EMPNO ON EMP(EMPNO); -- HOW TO CREATE INDEX
-- THIS DOENS'T WORK ATM. SINCE PRIMARY KEY IS ALREADY INDEX -ED

SELECT EMPNO, ROWID FROM EMP ORDER BY EMPNO;

-- UNIQUE SCAN: UNIQUE 한 컬럼 UNIQUE INDEX를 생성한 경우 발생
-- Range Scan

-- 결합 index--  Used in real like 
-- Where you need to condition 'Select' with particular combination and that is often used.
select * from student where grade = 4 and name = ' ';

-- DECENDING INDEX : Useful when you are searching higer or recent data!
CREATE INDEX INX_EMP_SAL_DESC ON EMP(SAL DESC);


--NON UNIQUE INDEX --
--EX) RANGE SCAN
CREATE INDEX INX_EMP_ENAME ON EMP(ENAME);
SELECT * FROM EMP WHERE ENAME = 'ALLEN';

DROP INDEX IDX_EMP_EMPNO;

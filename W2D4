--=============================WEEK 2 DAY 4=======================================--
-----------------------------KYUNG KWAN JANG---------------------------------------

--CREATE TABLE (MUST HAVE AUTHORITY)
CREATE TABLE EMP_BACKUP
AS
SELECT ENAME, EMPNO, SAL
  FROM EMP
 WHERE DEPTNO = 20;
 
 SELECT * FROM EMP_BACKUP;
 
 --**
 SELECT * FROM STUDENT;
 
 CREATE TABLE STD1
   AS
 SELECT * 
   FROM STUDENT
  WHERE 1=2;
  
 SELECT * FROM STD1;
 
 DESC STD1;
 
 ALTER TABLE STD1
 ADD (LOC2 VARCHAR2(10));
 
  ALTER TABLE STD1
 ADD (LOC1 VARCHAR2(10) DEFAULT '서울');
 
 DESC STD1;
 
 TRUNCATE TABLE STD1;
 
 DROP TABLE EMP_BACKUP;
 
 
 select * from user_recyclebin;
 
 delete from emp;
 
 select * from user_tables;
 
 select * from base_tables;
 
 --===DATA DICTIONARY VIEW====---
 
 DICTIONARY VIEW
 1) STATIC DATA DICTIONARY VIEW : 주로 DB 구조적 정보를 저장
 - USER_XXX : 접속한 유저의 소유 정보만 저장;
 SELECT* FROM USER_TABLES;
 SELECT * FROM USER_TAB_COLUMNS;                                -- TAB = TABLE
 
 - ALL_XXX  : 접속한 유저의 소유 + 관한이 부여됭 객체 정보 저장;  --SCOTT 도 가능
 SELECT * FROM ALL_TABLES;
 
 - DBA_XXX  : DBA관한을 가져랴만 조회 가능. 모든 객체 저장;
 SELECT * FROM DBA_TABLES;
 
 2) DYNAMIC PERFORMANCE VIEW    : 주로 DB의 성능 정보를 저장;
 - V$XXX;
 SELECT * FROM v$SESSION;                                           --SCOTT 안됨
 
 
 --> PRACTICE QUESTION

SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'EMP';
DESC EMP;

SELECT COLUMN_NAME,
       CASE NULLABLE
         WHEN 'Y' THEN NULL
         WHEN 'N' THEN 'NOT NULL'
       END AS Nullable,
       DATA_TYPE ||
       CASE
         WHEN DATA_TYPE = 'DATE' THEN NULL
         WHEN DATA_TYPE = 'VARCHAR2' THEN ' (' || DATA_LENGTH || ')'
         WHEN DATA_SCALE != 0 THEN ' (' || DATA_PRECISION || ', ' || DATA_SCALE || ')'
         ELSE ' (' || DATA_PRECISION || ')'
       END
  FROM USER_TAB_COLUMNS
 WHERE TABLE_NAME = 'EMP';
 
 -------) COMMENTING ON COLUM
 COMMENT ON COLUMN EMP.EMPNO IS 'EMPLOYEE NUMBER';
 SELECT * FROM USER_TAB_COMMENTS;
 SELECT * FROM USER_COL_COMMENTS;
 
 DESC EMP;
 
CREATE TABLE SCOTT.MEMBER2
(
    USERID        VARCHAR2(10),
    USERNAME      VARCHAR2(10),
    PASSWD        VARCHAR2(10),
    IDNUM         VARCHAR2(13),
    PHONE         NUMBER(13),
    ADDRESS       VARCHAR2(15),
    REGDATE       DATE,
    INTEREST      VARCHAR2(15)
) ;

COMMENT ON COLUMN MEMBER2.USERID IS '사용자아이디';
COMMENT ON COLUMN MEMBER2.USERNAME IS '회원이름';
COMMENT ON COLUMN MEMBER2.PASSWD IS '비밀번호';
COMMENT ON COLUMN MEMBER2.IDNUM IS '주민등록번호';
COMMENT ON COLUMN MEMBER2.PHONE IS '전화번호';
COMMENT ON COLUMN MEMBER2.ADDRESS IS '주소';
COMMENT ON COLUMN MEMBER2.REGDATE IS '가입일';
COMMENT ON COLUMN MEMBER2.INTEREST IS '관심분야';

SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME = 'MEMBER2';
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'MEMBER2';

SELECT UTC.COLUMN_NAME AS 컬럼이름,
       UTC.DATA_TYPE || CASE WHEN UTC.DATA_TYPE = 'DATE' THEN NULL ELSE ' (' || UTC.DATA_LENGTH || ')' END AS 데이터타입,
       UCC.COMMENTS AS 설명
  FROM USER_COL_COMMENTS UCC,
       USER_TAB_COLUMNS UTC
 WHERE UCC.TABLE_NAME = UTC.TABLE_NAME
   AND UCC.TABLE_NAME = 'MEMBER2'
   AND UCC.COLUMN_NAME = UTC.COLUMN_NAME;
   
   
----------------------A) TIP!-----------------------------------------------------------------------
CREATE TABLE EMP_BACK AS SELECT * FROM EMP;
-- DICTIONARY VIEW 활용 명령어 출력
SELECT 'CREATE TABLE ' || TABLE_NAME || '_BACK AS SELECT * FROM ' || TABLE_NAME || ';' FROM USER_TABLES; 
-----------------------------------------------------------------------------------------------------

---====================INSERT=================================-

SELECT * FROM EMP_BACK;

INSERT INTO EMP_BACK
VALUES(9999, 'LUKE', 'ENGINEER', 7902, SYSDATE, 10000, 5000, 10);
COMMIT;

INSERT INTO EMP_BACK(EMPNO, ENAME, SAL)
VALUES(9998, 'HONG', 3000);

--Must insert columns that are "NOT NULL"

INSERT INTO EMP_BACK
SELECT * FROM EMP WHERE DEPTNO = 10;        -----EMP_BACK & EMP MUST HAVE THE SAME STRUTURE!!


INSERT INTO EMP_BACK(EMPNO, ENAME, SAL, HIREDATE)
VALUES(0877, 'SOMEONE', 3000, TO_DATE('19/03/13', 'DD/MM/YY'));              --- DATE MUST BE THE RIGHT FORMAT
ROLLBACK;

---=====================UPDATE=============================---
---------------TROUBLESOME!!-----------------------

---UPDATE LUKE'S SALARY TO 99999
UPDATE EMP_BACK
SET SAL = 99999
WHERE ENAME = 'LUKE';
ROLLBACK;

SELECT * FROM EMP_BACK;

--------BEFORE COMMIT OR ROLLBACK, OTHER SESSIONS CAN'T FINISH PROCESS THEIR OWN QUERY REGARDS TO!!
--Therefore Rollback or Commit ASAP...

--UPDATE CAN BE DIFFICULT
UPDATE EMP_BACK
SET SAL = (......)
WHERE ENAME = (......);

--MAKE SMITH'S SAL SAME AS ALLEN
UPDATE EMP_BACK
SET SAL = (SELECT SAL FROM EMP_BACK WHERE ENAME = 'ALLEN')
WHERE ENAME = 'SMITH';
COMMIT;

--WHAT IF THERE ARE TWO ALLEN!! - DOESN'T WORK!
UPDATE EMP_BACK E1
   SET SAL = (SELECT SAL FROM EMP_BACK E2 WHERE E1.MGR = E2.EMPNO);
   
ROLLBACK;

SELECT SAL, (SELECT SAL FROM EMP E2 WHERE E1.MGR = E2.EMPNO)
  FROM EMP E1;
-----===================DELETE=====================================---
DELETE FROM EMP_BACK
WHERE DEPTNO = 10;

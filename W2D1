 ---=====================WEEK 2 D1===================================

------------------------KYUNG KWAN JANG-----------------------------

--============OUTER JOIN==================--

--LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN (NOT RECOMMENDED)--

--EX) FROM STUDENT TABLE, PRINT STUDENT NAME WITH FOLLWOWING PROFESSOR NAME (INCLUDING NULL)'   

----- SINCE IT'S STUDENT FOCUSED. LEFT OUTTER JOIN
SELECT DISTINCT PROFNO
  FROM STUDENT;
 
-- STUDENT TABLE HAS 20 ROWS
SELECT COUNT(PROFNO)
  FROM STUDENT
 GROUP BY PROFNO;
 
SELECT DISTINCT PROFNO
  FROM PROFESSOR;
 
-- 16 ROWS
SELECT S.NAME,
       P.NAME -- 15 ROWS SINCE NULL PLACE IS SKIPPED
  FROM STUDENT S,
       PROFESSOR P
 WHERE S.PROFNO = P.PROFNO;
 
SELECT S.NAME,
       P.NAME
  FROM STUDENT S,
       PROFESSOR P
 WHERE S.PROFNO = P.PROFNO(+);
 
--SINCE STUDENT IS 기준.. THEREFORE (+) ON THE OTHER SIDE

--EX2) PROFESSOR TABLE 에서 각 교수 이름을 출력하되, 지도학생이 있는 경우

-- 지도학생의 이름도 함께 출력. 

-- 단, 지도학생이 없는 교수도 출력
SELECT S.NAME AS STUDENT,
       P.NAME AS PROF
  FROM STUDENT S,
       PROFESSOR P
 WHERE S.PROFNO(+) = P.PROFNO
 ORDER BY 2;
 
--EX3) 교수 별 지도학생 수! -- WAY TO CHECK IF JOIN WORKS!
SELECT P.NAME,
       COUNT(S.NAME)
  FROM STUDENT S,
       PROFESSOR P
 WHERE S.PROFNO(+) = P.PROFNO
 GROUP BY P.NAME
 ORDER BY 2;
 
--========== SELF JOIN ================-- MOST DIFFICULT JOIN

-----OUTER JOIN AND SELF JOIN COMES HAND TO HAND!!! 90%

--같은 테이블을 여러번 참조/스켄 해야 하는 경우 사용

--FROM 정에 마치 서로다른 테이블 처럼 나열
SELECT *
  FROM EMP E1,
       EMP E2;
 
--EX) FROM EMP TABLE. LOOK AT MGR (MANAGER NUMBER), THAT NUMBER ALSO INCLUDES
SELECT E1.ENAME AS EMPLOYEE,
       E1.MGR AS MANAGER_NUM,
       E2.ENAME AS MANAGER_NAME
  FROM EMP E1,
       EMP E2
 WHERE E1.MGR = E2.EMPNO(+);
 
--EX2) 본인의 상사보다 더 많은 연봉을 받는 사람. 능력자를 찾아라!
SELECT E1.ENAME AS EMPLOYEE,
       E1.MGR AS MANAGER_NUM,
       E2.ENAME AS MANAGER_NAME,
       E1.SAL,
       E2.SAL
  FROM EMP E1,
       EMP E2
 WHERE E1.MGR = E2.EMPNO(+)
   AND E1.SAL > E2. SAL;
 
--EX3) DEPARTMENT TABLE, PRINT 학과의 상위학과 (PART)
SELECT D1.DEPTNO,
       D1.DNAME,
       D2.DNAME
  FROM DEPARTMENT D1,
       DEPARTMENT D2
 WHERE D1.PART = D2.DEPTNO(+);
 
--EX4) FROM EMP TABLE, 각 직원마다 같은부서 내 본인보다 연봉이 높은 직원수 출력
SELECT E1.ENAME,
       COUNT(E2.ENAME)
  FROM EMP E1,
       EMP E2
 WHERE E1.SAL < E2.SAL(+)
 GROUP BY E1.ENAME;
 
--****OUTER JOIN 이 두개이면 (+)! 
SELECT * FROM EMP2;

SELECT E1.ENAME, E1.SAL, E1.DEPTNO,
       COUNT(E2.ENAME)
  FROM EMP E1,
       EMP E2
 WHERE E1.DEPTNO = E2.DEPTNO(+)
   AND E1.SAL < E2.SAL(+)
 GROUP BY E1.ENAME, E1.SAL, E1.DEPTNO
  ORDER BY 2 DESC;
 
--EX5) USING EMP2, COUNT EMPLOYEES WITH THE SAME HOBBY PER DEPT****
SELECT * FROM EMP2
ORDER BY DEPTNO;

SELECT E1.NAME,
       E1.HOBBY,
       E1.DEPTNO,
       CASE COUNT(E2.NAME)
         WHEN 0 THEN 'NO HOBBY'
         ELSE TO_CHAR(COUNT(E2.NAME)-1)
       END same_hobby
  FROM EMP2 E1,
       EMP2 E2
 WHERE E1.HOBBY = E2.HOBBY(+)
   AND E1.EMP_TYPE = E2.EMP_TYPE(+)
 GROUP BY E1.NAME,
       E1.DEPTNO,
       E1.HOBBY
 ORDER BY 2;
 
-------BETTER(?) WHERE != IS USED...
SELECT E1.NAME,
       E1.HOBBY,
       E1.DEPTNO,
       COUNT(E2.EMPNO)
  FROM EMP2 E1,
       EMP2 E2
 WHERE E1.HOBBY = E2.HOBBY(+)
   AND E1.EMP_TYPE = E2.EMP_TYPE(+)
   AND E1.EMPNO != E2.EMPNO(+)
 GROUP BY E1.EMPNO, E1.NAME,   -----ONCE UNIQUE VARIABLE IS USED, EVEN HOBBY IS GROUPED NO REDUCTION IN ROWS
       E1.DEPTNO,               ---E1.NAME CAN BE DUPPLICATED. THEREOFRE EMPNO...!!!
       E1.HOBBY
 ORDER BY 2;
 
--EX6)FROM STUDENT TABLE, STUDENT NAME, GRADE, 지도교수, AND *지도교수의 소속 학과명
SELECT * FROM STUDENT;
SELECT * FROM PROFESSOR;
SELECT * FROM DEPARTMENT;
 
SELECT S.NAME,
       S.GRADE,
       P.NAME,
       D.DNAME
  FROM STUDENT S,
       PROFESSOR P,
       DEPARTMENT D
 WHERE S.PROFNO = P.PROFNO (+)
   AND P.DEPTNO = D.DEPTNO(+)
 ORDER BY S.GRADE DESC;
 
 s-p(+)
   |
   d(+)
   |
   e(+)
   
 a(+) -  b(+)       순환고리 불가능!!
 |       |
 d(+) -  c(+);
 
SELECT *
  FROM STUDENT S, PROFESSOR P
 WHERE S.PROFNO = P.PROFNO(+);
 
--WAY TO SOLVE ---- SUB QUERYT IS NEEDED!!
 (a -  b)
    |       
 (d -  c)(+);
 
SELECT *
  FROM STUDENT S, PROFESSOR P_01
 WHERE S.PRO

 
 

--================== WEEK 3 DAY 3

command prompt:
C:\Users\kitcoop>SQLPLUS HR/oracle

--========= VIEW =========---

CREATE OR REPLACE VIEW v_emp AS
SELECT ;

--VIEW를 통한 조회 시 SUB-QUERY...

--** VIEW 를 만드는 USER에게 CREATE VIEW 관한 부여  ( MUST BE SYSTEM ACCOUNT OR SYSDBA)
GRANT CREATE VIEW TO SCOTT;

--** VIEW는 저장공간을 가지고 있지 않는다!!

--생성된 VIEW 조회 방법!
SELECT * FROM USER_VIEWS; 

--VIEWF를 통한 수정 (IPDATE, INSERT, DELETE) 가능
-- (단, 원본테이블레 제약 조건을 그대로 따름)

CREATE OR REPLACE VIEW VIEW_EMP
AS
  SELECT EMPNO, ENAME, DEPTNO
    FROM EMP;

INSERT INTO VIEW_EMP VALUES(9876, 'A', 10);
SELECT * FROM VIEW_EMP;
SELECT * FROM EMP;

INSERT INTO VIEW_EMP VALUES(9877, 'BB', 50);    -- CASE WHERE CONSTRAINT IS ON PLAY!

ROLLBACK;

-- VIEW 생성 시 컬럼면 변경

CREATE OR REPLACE VIEW V_STUDENT(NO, SNAME, SGRADE)     ---ALIAS!!
AS
SELECT STUDNO, NAME, GRADE
  FROM STUDENT;

SELECT * FROM V_STUDENT;

CREATE OR REPLACE VIEW V_STUDENT    ---DIFFERNET WAY TO ALIAS!!
AS
SELECT STUDNO AS NO, NAME AS SNAME, GRADE AS SGRADE
  FROM STUDENT;

DROP VIEW V_STUDENT;                --- HOW TO DROP!


-- 복합 뷰 생성 COMPLEX VIEW --

CREATE VIEW V_STUD_EXAM
AS
SELECT S.STUDNO, S.NAME, E.TOTAL AS JUMSU
  FROM STUDENT S, EXAM_01 E
 WHERE S.STUDNO = E.STUDNO;
 
SELECT * FROM V_STUD_EXAM;

CREATE VIEW V_EMP_DNAME
AS
SELECT E.EMPNO, E.ENAME, D.DNAME
  FROM EMP E, DEPT D
 WHERE E.DEPTNO = D.DEPTNO;
 
INSERT INTO V_EMP_DNAME(EMPNO, ENAME) VALUES(1234, 'AA');   -- 가능!

INSERT INTO V_EMP_DNAME VALUES(1234, 'AA', 'AAAA');         -- 불!가! ONE TABLE AT A TIME!!

ROLLBACK;
SELECT * FROM V_STUD_EXAM;

---------------------------------------------------------------------------
ALTER TABLE TABLE_NAME ADD (COLUMN_NAME COL_TYPE DEFAULT 100);          -- 즉시 전체
ALTER TABLE TABLE_NAME MODIFY COL DEFAULT 10;      -- 이제 부터

SELECT * FROM STUDENT_BACK;
DESC STUDENT_BACK;

ROLLBACK;
----------------------------------------------------------------------------
ALTER TABLE STUDENT_BACK ADD (DEPTNO3 NUMBER(3) DEFAULT 201);
ALTER TABLE STUDENT_BACK MODIFY DEPTNO2 DEFAULT 10;


ALTER TABLE EMP ADD (COL1 VARCHAR2 (20) DEFAULT 10);
ALTER TABLE EMP MODIFY COL1 DEFAULT 10;
UPDATE /*+ PARALLEL(EMP 8) */ EMP             --'SMART WAY TO DO IT ... USE 16 CPU..?
   SET COL1 = 10;

ALTER TABLE EMP ADD (COL1 VARCHAR2 (20) DEFAULT 10);
SELECT * FROM EMP;

ALTER TABLE EMP ADD (COL2 VARCHAR2 (20));
ALTER TABLE EMP MODIFY COL2 DEFAULT 'A';
INSERT INTO EMP EMP(EMPNO, COL1, COL2) VALUES (3400, '23', '11');
INSERT INTO EMP EMP(EMPNO, COL1, COL2) VALUES (3401, NULL, '11');
INSERT INTO EMP EMP(EMPNO, COL2) VALUES (3402,  '11');
----------------------------------------------------------------------------

--=== SYNONYM / 시노님 / 동의어 ===--
-- 다른 테이블을 조회하고자 할 경우, 테이블의 조회 권한이 있어야 하며
-- 유저명. 테이블명 형식으로 조회해야 함
-- 이때 유저명. 테이블명 대신 테이블멸으로도 조회가 가능하도록 처리가능한
-- 테이블 별칭

SELECT * FROM HR.EMPLOYEES;

--EX)
CREATE OR REPLACE PUBLIC SYNONYM EMPLOYEES FOR HR.EMPLOYEES;

----- TYPES OF SYNONYM---
-- 1) PRIVATE   -- JUST YOUR ACCOUNT!  -- DEFUALT!!!!!!
-- 2) PUBLIC    -- TO ALL ACCOUNT!  -- USUALLY THIS.

SELECT * FROM EMPLOYEES;

--
SELECT * FROM ALL_SYNONYMS WHERE TABLE_OWNER = 'HR';

SELECT * FROM ALL_SYNONYMS WHERE TABLE_NAME = 'EMPLOYEES';

--==== SEQUENCE 시퀀스 ====---
-- 연속된 숫자의 자동 부여를 도와주는 객체

--EX) 은행 대기표 번호 처리 등 등...
CREATE SEQUENCE SEQ_JUMIN_NO
INCREMENT BY 1
START WITH 1000
MAXVALUE 1010
MINVALUE 990
CYCLE
CACHE 2;        --- 미리 연속된 번호를 생성해서 메모리에 저장, 동시에 번호 획득에 대한
                --- 부하를 방지
                
                --ex) 동시 접속자. 미리 뽑아 놓기!! 동시에 많은 발행하면 시간 걸리기 때문에.
                -- 많이 안씀. 이유! 메모리 날라가면 정보 날라감!! 저장이 안돼기 때문에!! 메모리 아웃 현상에 취약!!!

CREATE TABLE JUMIN
(J_NO NUMBER(4),
 J_NAME VARCHAR2(10));

ALTER TABLE JUMIN
MODIFY J_NAME VARCHAR2(10);

INSERT INTO JUMIN VALUES(SEQ_JUMIN_NO.NEXTVAL, 'AAAA');

SELECT * FROM JUMIN;

ROLLBACK;   --**!*!! EVEN ROLLBACK, SEQUENCE DOESN'T START OVER! 

--SEQUENCE 조회
SELECT SEQ_JUMIN_NO.CURRVAL FROM DUAL;
SELECT SEQ_JUMIN_NO.NEXTVAL FROM DUAL;

--1) HR 계정 소유의 아래의 테이블을 생성
CREATE TABLE CAFE_MENU(ID NUMBER, NAME VARCHAR2(10), PROCE NUMBER);

SELECT * FROM CAFE_MENU;

--2) ID COLUMN에 PK CONSTRAINT SETTING

ALTER TABLE CAFE_MENU
ADD CONSTRAINT cafe_munu_id_pk PRIMARY KEY(ID);

--3) 다음의 SQUENCE 생성, 사용하여 데이터 INSERT 1000번 부터 시작, 1100 까지 생성되고 1부터 재사용 되도록 설정

CREATE SEQUENCE SEQ_PRAC
START WITH 1000
MAXVALUE 1010
MINVALUE 1
cycle;

DROP SEQUENCE SEQ_PRAC;

SELECT SEQ_PRAC.CURRVAL FROM DUAL;
SELECT SEQ_PRAC.NEXTVAL FROM DUAL;

INSERT INTO CAFE_MENU VALUES(SEQ_PRAC.NEXTVAL, 'BIG MAC', 4.9);

SELECT * FROM CAFE_MENU;

CREATE VIEW V_CAFE_MENU
AS
SELECT * FROM CAFE_MENU;

ROLLBACK;
COMMIT;

--4) SCOTT 계정에서 조회가 가즌ㅇ하도록 설정
GRANT SELECT ON HR.CAFE_MENU TO SCOTT;              --system account!!
GRANT INSERT ON HR.CAFE_MENU TO SCOTT;

SELECT * FROM CAFE_MENU;

TRUNCATE TABLE CAFE_MENU;

CREATE OR REPLACE PUBLIC SYNONYM CAFE_MENU FOR HR.CAFE_MENU;

--DEFERRED SEQUENCE 

-- SEQUENCE 조회

SELECT * FROM USER_SEQUENCES;
-- LAST NUMBER IS CHASHE-ED NUMBEER!!!
-- THEREFOR YOU CAN'T CHECK ACTUAL CURRENT NUMBER VIA THIS VIEW!

--======= 권한 ===============-----
-- 권한의 집합! ROLL

1) 권한 부여
GRANT 권한 TO USER_NAME;

2) 권한 회수
REVOKE 권한 FROM USER_NAME;

2. 권한의 종류
1) 시스템 권한: CREATE TABLE, CREATE INDEX ....
2) OBJECTIVE 권한: SELECT ON EMP, DELETE ON STUDENT

3. ROLE : 권한의 집합!!

1) CREATE ROLE
CREATE ROLE ROLE1;

2) ROLE에 권한 담기 (권한 1, 권한 2, 권한 3, ... => ROLE 1에 부여)
GRANT 권한1, 권한2, 권한 3 TO ROLE1;

3) ROLE을 USER에서 부여 (재접솟 후 효력 발생!! (ctrl + n to reconnect!))
GRANT ROLE1 TO USER;

4. ROLE 조회
1) 생성된 롤 조회;
SELECT * FROM DBA_ROLES;

(가장 많이 사용하는 ROLE)
- CONNECT     : 접속 관련 ROLE
- RESOURCE    : 기본적인 시스텝 권한을 가지고 있는 ROLE
- DBA         : DBA가 필요로 하는 대부분의 권한을 가지고 있는 ROLE;

SELECT * FROM DBA_ROLE_PRIVS WHERE GRANTEE IN ('CONNECT', 'RESOURCE', 'DBA');

SELECT * FROM DBA_SYS_PRIVS WHERE GRANTEE IN ('CONNECT', 'RESOURCE', 'DBA') ORDER BY 1;  -- 다 조사

-- DBA_ROLES            : 생성된 롤
-- DBA_SYS_PRIVS        : USER별 시스템 권한
-- DBA_TAB_PRIVS        : USER죨 테이블 권한
-- DBA_ROLE_PRIVS
-- DBA_SYS_PRIVS
-- DBA_TAB_PRIVIS


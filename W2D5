--===========================WEEK 2 DAY 5================================---
-----------------------------KYUNG KWAN JANG--------------------------------

--====UPDATE====--
---SCALA QUERY IS GOOD WITH UPDATE!

UPDATE EMP_BACK 
   SET SAL = 1000
 WHERE ENAME = 'SMITH';
 
SELECT * FROM EMP_BACK;

UPDATE EMP_BACK
   SET SAL = SAL
 WHERE ENAME = 'ALLEN';
 
--한행에서 처리가능 하면 SUB QUERY 불필요?




--EX1) EMP_BACK 에서 10번 부서 직원의 연봉을 10% 인상된 연봉으로 업데이트
UPDATE EMP_BACK
   SET SAL = SAL*1.1
 WHERE DEPTNO = 10;
 
SELECT * FROM EMP_BACK;

--**BAD CASE--
UPDATE EMP_BACK
   SET SAL = (SELECT SAL*1.1 FROM EMP_BACK WHERE DEPTNO = 10);
   
--EX2) ADD 'SWX' COLUMN IN STUDENT TABLE
SELECT * FROM STUDENT;

ALTER TABLE STUDENT
  ADD (SEX VARCHAR2(10));

UPDATE STUDENT
  SET SEX = (DECODE(SUBSTR(JUMIN, 7,1), 1, 'MALE', 'FEMALE'));   
COMMIT;

--EX3) EMP 테이블에 AVG 컬럼을 만들고 평균..? 연봉으로 업데이트
SELECT * FROM EMP;

ALTER TABLE EMP ADD (AVG NUMBER);

UPDATE EMP
   SET AVG = (SELECT ROUND(AVG(SAL)) FROM EMP);

--EX3) EMP 테이블에 AVG 컬럼을 만들고 부서의 평균 연봉으로 업데이트 *********************
SELECT * FROM EMP;

UPDATE EMP E1
   SET AVG = (SELECT ROUND(AVG(SAL)) FROM EMP E2 WHERE E1.DEPTNO = E2.DEPTNO);  ---- NO NEED TO GROUP BY!
   
COMMIT;

--EX4) EMP TABLE 에서 AVG 컬럼 값을 각 직원과 메니저의 평균 연봉으로 수정
UPDATE EMP E1
   SET AVG = NVL((SELECT (E1.SAL+E2.SAL)/2 FROM EMP E2 WHERE E1.MGR = E2.EMPNO(+)), E1.SAL);
   
   SELECT (E1.SAL+NVL(E2.SAL, 0))/2, E1.ENAME FROM EMP E2, EMP E1 WHERE E1.MGR = E2.EMPNO(+);
   
 -- CHAR TYPE AND CARVHAR2 TYPE COMPARISION AND CAUSION
 -- CHAR HAS 'FIXED' LENGTH THEREFORE INPUT WITH LESS LEGNTH WILL BE EMPRY SPACE ( ) + VALUE
 -- VARCHAR2 WILL ELIMINATE THOSE EMPTY SPACES
 
 CREATE TABLE TEST
 ( CHAR_COL CHAR(4),
   VCHAR_COL VARCHAR2(4));
   
 INSERT INTO TEST VALUES('A', 'A');
 SELECT LENGTH(CHAR_COL), CHAR_COL, VCHAR_COL, LENGTH(VCHAR_COL) FROM TEST;
 
 SELECT * FROM TEST WHERE TRIM(CHAR_COL) = VCHAR_COL;
 
 
 ROLLBACK;

----- AUTO COMMIT...?
INSERT... UPDATE...
--THEN..
CREATE TABLE....    <-- THIS AUTO COMMIT;!
;


--====DELETE=======----
-- 전체 행 삭제 (WHERE 절 생략시)하거나 일부 조건에 맞은 행 삭제
-- DELETE로 특정 행의 특정 컬럼만 삭제 할수 없음 => UPDATE
-- DELTETE는 모든 삭제 기록을 남기기 깨문에  (아카이브 로그 모드일 경우)
-- TRUNCATE로 삭제 하는것 보다 훨씬 느리지만 복구가 가능
COMMIT;
SELECT * FROM EMP_BACK;
DELETE FROM EMP_BACK WHERE DEPTNO = 10;   ---* DELETE "BLANK" FROM EMP....

SELECT * FROM EMP;

INSERT INTO EMP_BACK
SELECT * FROM EMP WHERE DEPTNO = 10;

--========CONSTRAINT===================--

SELECT * FROM MEMBER2;
ADD CONSTRAINT ;

CREATE TABLE SCOTT.BOARD
(
    NO       NUMBER(4)
        CONSTRAINT board_no_pk PRIMARY KEY,
    SUBJECT  VARCHAR2(50)
        CONSTRAINT board_sub_nn NOT NULL,
    CONTENT  VARCHAR2(100),
    RDATE    DATE,
    USERID   VARCHAR2(10)
)
;

ALTER TABLE MEMBER2
ADD CONSTRAINT member2_idnum_uk UNIQUE(IDNUM);

--ALTER TABLE MEMBER2                           --DOESN'T WORK
--ADD CONSTRAINT member2_username_nn NOT NULL(USERNAME)
--ADD CONSTRAINT member2_password_nn NOT NULL(PASSWORD);

ALTER TABLE MEMBER2
MODIFY (USERNAME CONSTRAINT member2_username_nn NOT NULL)
--MODIFY (USERNAME NOT NULL)
MODIFY (PASSWD CONSTRAINT member2_passwd_nn NOT NULL);

ALTER TABLE BOARD
ADD CONSTRAINT board_userid_fk FOREIGN KEY(USERID) REFERENCES MEMBER2(USERID);

--** FK를 만들 경우 REFERENCE KEY는 반드시 UNIQUE OR PK 를 가져야 함.

DESC MEMBER2;
DESC BOARD;

SELECT* FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'BOARD';
COMMENT ON COLUMN BOARD.NO IS '게시물 번호';
COMMENT ON COLUMN BOARD.SUBJECT IS '제목';
COMMENT ON COLUMN BOARD.CONTENT IS '내용 ';
COMMENT ON COLUMN BOARD.RDATE IS '작성일자';
COMMENT ON COLUMN BOARD.USERID IS '글쓴이 ';

SELECT * FROM USER_COL_COMMENTS WHERE TABLE_NAME = 'BOARD';
SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'BOARD';

---------NOW TESTING----------------

DESC MEMBER2;

INSERT INTO MEMBER2(USERID, USERNAME, PASSWD)
VALUES ('0001', 'LUKE', 'A123');
INSERT INTO MEMBER2(USERID, USERNAME, PASSWD)
VALUES ('0002', 'JAKE', 'AD123');
INSERT INTO MEMBER2(USERID, USERNAME, PASSWD)
VALUES ('0004', 'HONG', '4323');
COMMIT;

DESC BOARD;
INSERT INTO BOARD(NO, SUBJECT)
VALUES (1000, 'THIS WAS FUN');
INSERT INTO BOARD(NO, SUBJECT)
VALUES (1001, 'THIS WAS FUN');
INSERT INTO BOARD(NO, SUBJECT)
VALUES (1002, 'THIS WAS FUN');

INSERT INTO BOARD(NO, SUBJECT, USERID)
VALUES (1003, 'THIS WAS SO FUN', '0001');
INSERT INTO BOARD(NO, SUBJECT, USERID)
VALUES (1007, 'THIS WAS SO FUN', '0004');
ㅁ
SELECT * FROM BOARD;            ----USERID (FK) STILL HAVE NULL! WHICH IS FINE
SELECT * FROM MEMBER2;
--부모 테이블의 REFERNECE KEY (MEMBER2 TABLE 의 USERID COLUMN)에 존재하지 않는 데이터는
--자식 테이블의 FK COLUMN (BOARD 테이블 USERID 컬럼) 값으로 들어 갈 수없다
COMMIT;
BOARD(USERID) -> MEMBER2(USERID);

DELETE FROM MEMBER2 WHERE USERID = '0004';      -- DOESN'T WORK. HAS A CHILD
DELETE FROM MEMBER2 WHERE USERNAME ='LUKE';
-- 자식 테이블에 데이터가 존제하면 부모 테이블 삭제 먼저 불가!!! (FK가 걸려있을 경우)

DESC STUDENT_BACK;

DESC TEST;

ALTER TABLE TEST
ADD (CTAS VARCHAR2(4) NOT NULL);

ALTER TABLE BOARD MODIFY (CONTENT NOT NULL);
ALTER TABLE BOARD MODIFY (SUBJECT NOT NULL);

SELECT * FROM BOARD;

ALTER TABLE BOARD MODIFY(NO VARCHAR2(5));               -- DOESN'T WORK WHEN NO HAS VALUE ALREADY!

DELETE FROM BOARD;
ROLLBACK;


--=========================WAYS TO CHECK
SELECT TABLE_NAME,          -- 제약조건이 생성된 테이블
       CONSTRAINT_NAME,     -- 제약조건 이름
       CONSTRAINT_TYPE,     -- 제약조건 (P:PK, U:UK, C: CHECK OR NOT NULL, R:FK)
       R_CONSTRAINT_NAME
  FROM USER_CONSTRAINTS
 WHERE 1=1 --DOESN'T MEAN ANYTHING. FOR TIP!
   AND TABLE_NAME = ''--.
   AND CONSTRAINT_NAME =''--/..
;

SELECT R_CONSTRAINT_NAME FROM USER_CONSTRAINTS;     --참조 제약조건 이름  REFERENCE CONSTRAINT NAME??
SELECT * FROM USER_CONSTRAINTS;
